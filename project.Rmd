---
title: __Spotify Top 100 Analysis__
author: "_Juanrico Alvaro, Mikhael Enrico Setianto, Renaldo Fareza Tambunan_"
date: "2022-07-13"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Group Members
1. Mikhael Enrico Setianto [702300] 
2. Juanrico Alvaro [702301]
3. Renaldo Fareza Tambunan [702314]

## __2. PROJECT REQUIREMENT__
### 2.1 Introduction to the Project
Spotify is the most well-known music streaming app in the world, users can access millions of songs and also many podcasts around the world. Nowadays, Spotify can be found on almost every device, especially among the millennials, because of its multi-platform apps and free to use.

Spotify is free, but for more convenient features the user can subscribe to Spotify Premium which the minimum cost around $10 per month. The features that the user can get as the premium user is the ability to disable ads and also unlimited songs skip. For this project, we are going to use dataset that is provided by Spotify to perform some exploratory data analysis using R language.

### 2.2 Problems Need to be Solved
Spotify provide a dataset of all daily hit charts curated by Spotify that is published on Kaggle website ( [Visit Website](https://kaggle.com) ). The data will contain top 100 song from 2010 until 2019 with .xslx data format and 1000 total records from the past ten years. This dataset is still unprocessed and there is more room to do more exploratory and predictive data analysis.


### 2.3  Data Analysis Specifications
The objective of this system is to read the data in analysis manner with this functionality:

* Get top popular song genre for every 5 year
* Get top popular artist for every 5 year
* Get song that was released outside the chart year range
* Get artist which appeared on the charts maximum number of times
* Show the relationship between music features
* Show the trend of BPM, Energy, Danceability, Live, Acoustic, Speechabilty,  Popularity from 2010 to 2019
* Create top genre model and get the best K for the prediction (predict using KNN)

### 2.4  Project Scope
The project will be revolving around descriptive and predictive analysis on Spotify. We are going to use R Language as the programming language and R Studio as the IDE. Later will be delivered as HTML document generated by R Markdown.

## __3. DATA PREPARATION__
We will prepare the data frame through some processes so that the data frame will be ready for prediction and exploratory analysis purposes.

### 3.1 Data Acquiring
We will read the data from kaggle that has been given in csv format using read.csv

```{r}
df<-read.csv(file = "Spotify_2010_-_2019_Top_100.csv",header = TRUE, sep=",")
head(df,5)
nrow(df)
```

### 3.2 Data Cleaning
#### _Removing NA value_
Check if there is NA value inside the dataframe.
```{r}
nrow(which(is.na(df), arr.ind=TRUE))
```

There are 36 position that is filled with NA value now we can remove those na value.

```{r}
df <- na.omit(df)
nrow(df)
```

#### _Changing Date Release data type_
The date format use ASCII value as the hypen. We need to process it by removing a non-alpha numeric using gsub() function and reformat it using as.Date() function. below we will show the class of date release.

```{r}
df$added<-gsub("[[:punct:]]", "", df$added)
df$added <- as.Date(df[["added"]], "%Y%m%d")
class(df$added)
```

### 3.3 Data Transformation
#### _Simplify the data frame_
Since we will do some prediction on the song genre it is better to classified the genre into a simpler form

```{r}
length(unique(df$top.genre))
```

As we can see there are hundreds of genre so we will classified it into 17 major genre. Here is our dictionary and implementation

```{r}
genre_dict <- c(
  "dance pop","pop", 
  "pop soul","soul",
  "atl hip hop","hip hop",
  "pop rap","rap",
  "big room","house",
  "canadian hip hop","hip hop",
  "disco house","house",
  "romanian house","house",
  'lilith',"indie",
  'detroit hip hop',"hip hop", 
  'asian american hip hop',"hip hop", 
  'east coast hip hop', "hip hop",
  'neo mellow',"pop", 
  'canadian pop',"pop", 
  'reggae fusion',"reggae", 
  'idol',"pop", 
  'art pop',"pop",
  "talent show","pop", 
  'modern alternative rock',"rock",
  'indietronica',"electronic", 
  'grime',"hip hop", 
  'barbadian pop',"pop", 
  'acoustic pop',"pop",
  'dutch house',"house", 
  'belgian pop',"pop", 
  'contemporary country',"country", 
  'boy band',"pop",
  'celtic rock',"rock", 
  'edm',"electronic", 
  'indie rock',"indie", 
  'australian dance',"dance",
  'british soul',"soul", 
  'eau claire indie',"indie", 
  'dancefloor dnb',"dance",
  'permanent wave',"rock", 
  'hip pop',"pop", 
  'g funk',"funk", 
  'baroque pop',"pop", 
  'indie pop',"pop",
  'chicago rap',"rap", 
  'indie poptimism',"indie", 
  'french shoegaze',"rock",
  'alternative metal',"metal", 
  'indie folk',"indie", 
  'alternative rock',"rock",
  'uk hip hop',"hip hop", 
  'electro house',"house", 
  'garage rock',"rock", 
  'israeli pop',"pop",
  'alternative r&b',"r&b", 
  'australian pop',"pop", 
  'candy pop',"pop", 
  'modern rock',"rock",
  'conscious hip hop',"hip hop", 
  'folk-pop',"pop", 
  'alternative dance',"dance", 
  'k-pop',"pop",
  'gangster rap',"rap", 
  'brostep',"dance", 
  'downtempo',"pop", 
  'la indie',"indie", 
  'bass trap',"dance",
  'metropopolis',"pop", 
  'electropop',"pop", 
  'electro',"electronica", 
  'destroy techno',"dance", 
  'emo',"rock",
  'austrian pop',"pop", 
  'irish pop',"pop", 
  'adult standards',"pop", 
  'modern folk rock',"rock",
  'tropical house',"house", 
  'contemporary r&b',"r&b", 
  'deep disco house',"house",
  'bubblegum dance',"dance", 
  'chill pop',"pop", 
  'comic',"pop", 
  'complextro',"electronica", 
  'nyc rap',"rap",
  'deep groove house',"house", 
  'australian hip hop',"hip hop", 
  'neo soul',"soul",
  'deep house',"house", 
  'french indie pop',"pop", 
  'german pop',"pop", 
  'dutch hip hop',"hip hop",
  'aussietronica',"electronica", 
  'australian indie',"indie", 
  'canadian contemporary r&b',"r&b",
  'kentucky hip hop',"hip hop", 
  'new jersey rap',"rap", 
  'irish singer-songwriter',"pop",
  'ghanaian hip hop',"hip hop", 
  'icelandic indie',"indie", 
  'indie pop rap',"pop",
  'new french touch',"pop", 
  'san diego rap',"rap", 
  'australian psych',"rock",
  'canadian indie',"indie", 
  'alt z',"pop", 
  'danish pop',"pop", 
  'melodic rap',"rap",
  'social media pop',"pop", 
  'london rap',"rap", 
  'florida rap',"rap", 
  'emo rap',"rap",
  'latin',"dance", 
  'ohio hip hop',"hip hop", 
  'dfw rap',"rap", 
  'hawaiian hip hop',"hio hop",
  'dirty south rap',"rap", 
  'afroswing',"swing", 
  'basshall',"dance", 
  'memphis hip hop',"hip hop",
  'bedroom pop',"pop", 
  'hollywood',"pop", 
  'afrofuturism',"pop", 
  'comedy rap',"rap",
  'colombian pop',"pop", 
  'cali rap',"rap", 
  'black americana',"pop",
  'north carolina hip hop',"hip hop", 
  'alternative pop rock',"pop", 
  'dark clubbing',"dance",
  'lgbtq+ hip hop',"hip hop", 
  'afro dancehall',"dance", 
  'argentine hip hop',"hip hop",
  'classic rock',"rock", 
  'uk drill',"hip hop")
val = 0
while (val <= 258)
{
  tempval <- val
  df["top.genre"][df["top.genre"] == genre_dict[tempval+1]] <-  as.character(genre_dict[tempval+2])
  val = val + 2
}

length(unique(df$top.genre))
```

#### _Ordinal Encoder_
Now, we will do an ordinal encoder to the variable that will be required to do the calculation. This transformation will change the character data type that act as a category to number data type. Here is the function to do the encoding.

```{r}
encode_ordinal <- function(x, order = unique(x)) {
  x <- as.numeric(factor(x, levels = order, exclude = NULL))
  x
}
```

Now we can choose the data that will be encoded. In this case we will encode artist.type column 

```{r}
new.col.artist.type<-encode_ordinal(df[["artist.type"]])
df$artist.type.enc<-new.col.artist.type
head(df)
```

We will also encode the top.genre column

```{r}
new.col.top.genre<-encode_ordinal(df[["top.genre"]])
df$top.genre.enc<-new.col.top.genre
head(df)
```

#### _Prediction Data_
#### Normalization
We will need to normalize every learning feature. In this case we will use all of the class that have a number attribute that we are going to apply the normalize function. The logic of normalize is to make all of the outliers data not too far off the middle value. In other words, this is an action to eliminate the outlier data. 

The formula to do the normalization is:

\begin{equation}
Normalization = \frac {x - min(x)} {max(x) - min(x)}
\end{equation}

```{r}
normalize <- function(x) {
  return ((x - min(x)) / (max(x) - min(x))) }
```

Now, lets assign the data to a new subset, we dont need to assign the genre to the new subset yet. since we do not want to normalize the target of our prediction.

```{r}
df.subset <- df[,6:15]
df.subset$artist.type.enc <- new.col.artist.type
```

After that we can apply the normalization, and add genre to the normalized subset

```{r}
df.subset <- as.data.frame(lapply(df.subset, normalize))
df.subset$top.genre.enc <- new.col.top.genre
head(df.subset)
```

We can see that now everything has been normalized except the genre.


#### _Remove duplicate data_
We can now removing the duplicate data since duplicate data can effect the result into an over-fitting model.

```{r}
df.subset <- unique(df.subset)
```

### 3.4 Dataset for Analysis
The dataset that we will use is the dataframe that is already processed before. We will assign the data into a new dataframe variable to keep the original dataframe. We will also show the preview with each of the class attribute

```{r}
df.song<-df
head(df.song)
sapply(df.song, class)
```

Data for prediction

```{r}
df.subset.song<-df.subset
head(df.song)
sapply(df.song, class)
```

## __4. Data Analysis__
The analysis that we will perform is based on the objectives of this project, such as, get the top genre and artist in every 5 year, showing the relationship between music features and so on.

### 4.1 Data Model
#### 4.1.1 Exploratory Data
We will need 3 types of model data. Which is the original data, first five year data and last five year data. This model will be use for exploratory data analysis.
```{r}
df.song.first <- df.song[ which( df.song$top.year >= 2010 & df.song$top.year <= 2014),]
df.song.second <- df.song[ which( df.song$top.year >= 2015 & df.song$top.year <= 2019),]

unique(df.song.first$top.year)
unique(df.song.second$top.year)
```

#### 4.1.2 Prediction Data
For the prediction data, we need to splice the data into two. Data splicing basically involves splitting the data set into training and testing data set. We can do this by using a seeder so that the result can be the same even after run in a multiple time. Code below will show how it works

```{r}
set.seed(23231)
dat.d <- sample(1:nrow(df.subset.song),size=nrow(df.subset.song)*0.7,replace = FALSE) #random selection of 70% data.

train <- df.subset.song[dat.d,] # 70% training data
test <- df.subset.song[-dat.d,] # remaining 30% test data

#Creating seperate dataframe for 'Creditability' feature which is our target.
train_labels <- df.subset.song[dat.d,12]
test_labels <-df.subset.song[-dat.d,12]
```

### 4.2 Data Analysis Method
_Install needed library_

```{r}
#install.packages('tidyverse')
#install.packages('reshape')
#install.packages('reshape2')
#install.packages('gridExtra')
#install.packages('class')
#install.packages('corrplot')
#install.packages('ggplot2')
library(ggplot2)
library(knitr)
library(class)
library(corrplot)
library(gridExtra)
library(reshape)
library(reshape2)
library(tidyverse)
```

#### 4.2.1 Get Top Popular Song Genre for Every 5 Year
We can do this by extracting the most occurrances in the genre column for every 5 year

#### First Five Year

```{r}
popular.genre.first <- df.song.first %>% 
  group_by(top.genre) %>% 
  tally(sort = TRUE) %>% 
  filter(row_number() <= 10)
```

#### Second Five Year

```{r}
popular.genre.second <- df.song.second %>% 
  group_by(top.genre) %>% 
  tally(sort = TRUE) %>% 
  filter(row_number() <= 10)
```

#### 4.2.2 Get Top Popular Artist for Every 5 Year
We can do this by extracting the most occurrances in the artist column for every 5 year

#### First Five Year

```{r}
popular.artist.first <- df.song.first %>% 
  group_by(artist) %>% 
  tally(sort = TRUE) %>% 
  filter(row_number() <= 10)
```

#### Second Five Year

```{r}
popular.artist.second <- df.song.second %>% 
  group_by(artist) %>% 
  tally(sort = TRUE) %>% 
  filter(row_number() <= 10)
```

#### 4.2.3 Get Songs that Was Released Outside the Chart Year Range 
We can do this by subset the song dataframe into list of song that is released before 2010

```{r}
df.song.released.outside <- df.song[ which( df.song$year.released < 2010),]
```

#### 4.2.4 Get Artist which Appeared on the Charts Maximum Number of Times

```{r}
popular.artist <- df.song %>% 
  group_by(artist) %>% 
  tally(sort = TRUE) %>% 
  filter(row_number() <= 10)
```

#### 4.2.5 Show the Relationship Between Music Features
In order to show the relationship between music features, we are using correlation matrix. Correlation Matrix is a table that displays correlation coefficients between different variables.

In R language, we can use cor() function to compute the correlation coefficient for each variable.
```{r}
corrsong<-cor(df.subset.song)
```

#### 4.2.6 Show the Trend of BPM, Energy, Danceability, Live, Value, Acoustic, Speechabilty, Popularity From 2010 to 2019
First, we calculate all the variable's mean for each year by using aggregate() function as shown below

```{r}
bpm_mean<-aggregate(df.song$bpm, list(df$top.year), FUN=mean)
nrgy_mean<-aggregate(df.song$nrgy, list(df$top.year), FUN=mean)
dnce_mean<-aggregate(df.song$dnce, list(df$top.year), FUN=mean)
live_mean<-aggregate(df.song$live, list(df$top.year), FUN=mean)
val_mean<-aggregate(df.song$val, list(df$top.year), FUN=mean)
acous_mean<-aggregate(df.song$acous, list(df$top.year), FUN=mean)
spch_mean<-aggregate(df.song$spch, list(df$top.year), FUN=mean)
pop_mean<-aggregate(df.song$pop, list(df$top.year), FUN=mean)
```

#### 4.2.7 Create Top Genre Model and Get the Best K for The Prediction (Predict Using KNN)
Since we’re using the KNN algorithm to build the model, we are going to use the library 'class' since the library is containing the KNN function. So, we can get the number of training to roughly determine what is the best K value to be use as our model. One of the ways to find the optimal K value is to calculate the square root of the total number of training data in the data set.

```{r}
NROW(train_labels) 
```

The square root of 700 is around 26.04, therefore we’ll create three models. One with ‘K’ value as 26 and the other model with a ‘K’ value as 27 also 25.

```{r}
knn.25 <- knn(train=train, test=test, cl=train_labels, k=25)
knn.26 <- knn(train=train, test=test, cl=train_labels, k=26)
knn.27 <- knn(train=train, test=test, cl=train_labels, k=27)
```

### 4.3 Data Analysis Result
#### 4.3.1 Get Top Popular Song Genre for Every 5 Year
#### First Five Year

```{r}
popular.genre.first
sprintf("The best genre is %s",popular.genre.first[[1]][1])
```

#### Second Five Year

```{r}
popular.genre.second
sprintf("The best genre is %s",popular.genre.second[[1]][1])
```

#### 4.3.2 Get Top Popular Artist for Every 5 Year
#### First Five Year

```{r}
popular.artist.first
sprintf("The best artist is %s",popular.artist.first[[1]][1])
```

#### Second Five Year

```{r}
popular.artist.second
sprintf("The best artist is %s",popular.artist.second[[1]][1])
```

#### 4.3.3 Get Songs that Was Released Outside the Chart Year Range 

```{r}
head(df.song.released.outside)
```

#### 4.3.4 Get Artist which Appeared on the Charts Maximum Number of Times
```{r}
popular.artist
sprintf("The best artist is %s",popular.artist[[1]][1])
```

#### 4.3.5 Show the Relationship Between Music Features
```{r}
df.subset.song%>%
  cor()%>%
  melt()%>%
  ggplot(aes(Var1, Var2, fill=value))+
  geom_tile(color='white')+
  scale_fill_distiller(palette = 'RdPu',direction = 1)+
  geom_text(aes(label=paste(round(value,2)*100,'%')), size=2.5, color='black')+
  labs(x='',y='',fill='correlations', title='Relationship Between Music Features')+
  theme(axis.text.x = element_text(angle = 90, vjust = .5))
```

It is shown that songs that have more Danceability, Acoustic, and more Popular are the top hit in recent year. Also, songs that have longer Duration and more Energy are the top hit in past year.


#### 4.3.6 Show the Trend of BPM, Energy, Danceability, Live, Value, Acoustic, Speechabilty, Popularity From 2010 to 2019
By using ggplot() we are showing the trend of each variable in the span of 10 years starting from 2010 to 2019
```{r}
bpm<-bpm_mean%>%
  ggplot(aes((`Group.1`), x))+
  geom_point(color='black')+
  geom_line(group=1, color='blue')+
  theme_bw()+
  scale_x_continuous(breaks = seq(2010,2019,2))+
  labs(title='BPM Average per Year', y='BPM', x='Year')
nrgy<-nrgy_mean%>%
  ggplot(aes((`Group.1`), x))+
  geom_point(color='black')+
  geom_line(group=1, color='green')+
  theme_bw()+
  scale_x_continuous(breaks = seq(2010,2019,2))+
  labs(title='Energy Average per Year', y='nrgy', x='Year')
dnce<-dnce_mean%>%
  ggplot(aes((`Group.1`), x))+
  geom_point(color='black')+
  geom_line(group=1, color='red')+
  theme_bw()+
  scale_x_continuous(breaks = seq(2010,2019,2))+
  labs(title='Danceability Average per Year', y='dnce', x='Year')
live<-live_mean%>%
  ggplot(aes((`Group.1`), x))+
  geom_point(color='black')+
  geom_line(group=1, color='magenta')+
  theme_bw()+
  scale_x_continuous(breaks = seq(2010,2019,2))+
  labs(title='Live Average per Year', y='live', x='Year')
val<-val_mean%>%
  ggplot(aes((`Group.1`), x))+
  geom_point(color='black')+
  geom_line(group=1, color='orange')+
  theme_bw()+
  scale_x_continuous(breaks = seq(2010,2019,2))+
  labs(title='Value Average per Year', y='val', x='Year')
acous<-acous_mean%>%
  ggplot(aes((`Group.1`), x))+
  geom_point(color='black')+
  geom_line(group=1, color='purple')+
  theme_bw()+
  scale_x_continuous(breaks = seq(2010,2019,2))+
  labs(title='Acoustic Average per Year', y='acous', x='Year')
spch<-spch_mean%>%
  ggplot(aes((`Group.1`), x))+
  geom_point(color='black')+
  geom_line(group=1, color='brown')+
  theme_bw()+
  scale_x_continuous(breaks = seq(2010,2019,2))+
  labs(title='Speechability Average per Year', y='spch', x='Year')
pop<-pop_mean%>%
  ggplot(aes((`Group.1`), x))+
  geom_point(color='black')+
  geom_line(group=1, color='navy')+
  theme_bw()+
  scale_x_continuous(breaks = seq(2010,2019,2))+
  labs(title='Popular Average per Year', y='pop', x='Year')

```

```{r}
grid.arrange(bpm, nrgy, dnce, live, ncol=2, nrow =2)
```

```{r}
grid.arrange(val, acous, spch, pop, ncol=2, nrow =2)
```


#### 4.3.7 Create Top Genre Model and Get the Best K for The Prediction (Predict Using KNN)
Now we can calculate the proportion of correct classification for k = 26, 27 after building the model according those K value.

```{r}
ACC.25 <- 100 * sum(test_labels == knn.25)/NROW(test_labels)
ACC.26 <- 100 * sum(test_labels == knn.26)/NROW(test_labels)
ACC.27 <- 100 * sum(test_labels == knn.27)/NROW(test_labels)
sprintf("Accuracy for K-Value 25 : %f",ACC.25)
sprintf("Accuracy for K-Value 26 : %f",ACC.26)
sprintf("Accuracy for K-Value 27 : %f",ACC.27)
```

We can also get the best k-value for this prediction by using a function that check all of the optimal k by looping until the number of k-value that we desire. In this case let us loop it until k-value 30

```{r}
i=1
k.optm=1
for (i in 1:30){
  knn.mod <- knn(train=train, test=test, cl=train_labels, k=i)
  k.optm[i] <- 100 * sum(test_labels == knn.mod)/NROW(test_labels)
  k=i
  cat(k,'=',k.optm[i],'\n')
}
```

## __5. Data Visualization__
We are showing our analysis results in the form of plots and tables using ggplot(), plot(), corrplot(), and kable() functions.

#### 5.1 Get Top Popular Song Genre for Every 5 Year
#### First Five Year

```{r}
ggplot(data = popular.genre.first, aes(x = top.genre, y = n)) +
  geom_col() +
  facet_grid(.~top.genre, scales = "free_x")
```

#### Second Five Year

```{r}
ggplot(data = popular.genre.second, aes(x = top.genre, y = n)) +
  geom_col() +
  facet_grid(.~top.genre, scales = "free_x")
```

#### 5.2 Get Top Popular Artist for Every 5 Year
#### First Five Year

```{r}
ggplot(data = popular.artist.first, aes(x = artist, y = n)) +
  geom_col() +
  facet_grid(.~artist, scales = "free_x")
```

#### Second Five Year

```{r}
ggplot(data = popular.artist.second, aes(x = artist, y = n)) +
  geom_col() +
  facet_grid(.~artist, scales = "free_x")
```

#### 5.3 Get Songs that Was Released Outside the Chart Year Range 
To make it look simple, we will just show several column
```{r}
df.song.released.outside.subset<-df.song.released.outside[,1:4]
df.song.released.outside.subset$top.year<-df.song.released.outside$top.year
df.song.released.outside.subset$artist.type<-df.song.released.outside$artist.type
row.names(df.song.released.outside.subset)<-1:nrow(df.song.released.outside.subset)
kable(df.song.released.outside.subset, caption = "Song that was released outside the chart year range ")
```

#### 5.4 Get Artist which Appeared on the Charts Maximum Number of Times

```{r}
ggplot(data = popular.artist, aes(x = artist, y = n)) +
  geom_col() +
  facet_grid(.~artist, scales = "free_x")
```

#### 5.5 Show the Relationship Between Music Features
For the visualization part, we are going to use some methods that are provided in the corrplot() library, as shown below: 
```{r}
corrplot(corrsong,method = "circle")
corrplot(corrsong,method = "pie")
corrplot(corrsong,method = "color")
corrplot(corrsong,method = "number")
```

#### 5.6 Show the Trend of BPM, Energy, Danceability, Live, Value, Acoustic, Speechabilty, Popularity From 2010 to 2019
```{r}
grid.arrange(bpm, nrgy, dnce, live, ncol=2, nrow =2)
```

```{r}
grid.arrange(val, acous, spch, pop, ncol=2, nrow =2)
```


#### 5.7 Create Top Genre Model and Get the Best K for The Prediction (Predict Using KNN)
We can plot the best K-value for the genre prediction
```{r}
plot(k.optm, type="b", xlab="K-Value",ylab="Accuracy level")
```

## __6. Conclusion__
This project confirms that many things that we can explore and analyze  using the provided dataset by Spotify. Althought, at first, we are struggling in using the dataset due to ambiguity in some columns value and class, but we manage to fix that and properly use the dataset in out project

For the data exploratory, we managed to get the top genre and artist in every 5 years(2010-2014 and 2015-2019) which the result are "pop" for both of the genre and "Calvin Harris" and "Drake" for the artist while the most popular artist in the span of 10 years is "Taylor Swift". We also managed to extract some songs that relased before 2010 (Outside the chart year range). For the trend in some of the music features we can infer that Energy and Live aspect have negative trends over the past 10 years, meanwhile Danceability, Acoustic, and Speechability have postive trends over the past 10 years. For the rest, showing inconsistent trend. 

For data prediction we can see that there is a probability of getting close to 100% ( 99.65636% ) prediction this means that the model will have a better accuracy when we pick 1 as our k-value.

In overall, using R Markdown in this project is quite convenient, because R Markdown facilitate the functionality of R language it self, so it is easier to produce the project report. 
