---
title: "Spotify Top 100 Analysis"
author: "Juanrico Alvaro, Mikhael Enrico Setianto, Renaldo Fareza Tambunan"
date: "2022-07-13"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Group Members
1. Mikhael Enrico Setianto [702300] 
2. Juanrico Alvaro [702301]
3. Renaldo Fareza Tambunan [702314]

## 2. PROJECT REQUIREMENT
### 2.1 Introduction to the project
Spotify is the most well-known music streaming app in the world, users can access millions of songs and also many podcasts around the world. Nowadays, Spotify can be found on almost every device, especially among the millennials, because of its multi-platform apps and free to use.

Spotify is free, but for more convenient features the user can subscribe to Spotify Premium which the minimum cost around $10 per month. The features that the user can get as the premium user is the ability to disable ads and also unlimited songs skip. For this project, we are going to use Spotify daa to do some analysis.

### 2.2 Problems need to be solved
Spotify offer a dataset of all daily hit charts curated by Spotify that is published on Kaggle website ( [Visit Website](https://kaggle.com) ). The data will contain top 100 song from 2010 until 2019 with xslx data format and total 1000 total record for the past ten years. This dataset is still unprocessed and there is more room to do more exploratory and predictive data analysis.


### 2.3  Data analysis specifications
The objective of this system is to read the data in analysis manner with this functionality:

* Get top popular song genre for every 5 year
* Get top popular artist for every 5 year
* Get average duration each year
* Get artist which appeared on the charts maximum number of times
* Create top genre model and get the best K for the prediction (predict using KNN)

### 2.4  Project scope
The project will be revolving around descriptive and predictive analysis on Spotify. We are going to use R Programming as the programming language and R Studio as the IDE. Later will be delivered as HTML document generated by R Markdown.

## 3. DATA PREPARATION
We will create a data preparation for prediction and exploratory purposes.
### 3.1 Data acquiring
We will read the data from kaggle that has been given in csv format using read.csv
```{r}
df<-read.csv(file = "Spotify_2010_-_2019_Top_100.csv",header = TRUE, sep=",")
head(df,5)
nrow(df)
```

### 3.2 Data Cleaning
#### Removing NA value
check if there is NA value inside the dataframe.
```{r}
nrow(which(is.na(df), arr.ind=TRUE))
```
There are 36 position that is filled with NA value now we can remove those na value.
```{r}
df <- na.omit(df)
nrow(df)
```
#### Changing Date Release datatype
The date format use ascii value as the hypen. We need to process it by removing a non alpha numeric using gsub function and reformat it using as.Date() function. below we will show the class of date release.
```{r}
df$added<-gsub("[[:punct:]]", "", df$added)
df$added <- as.Date(df[["added"]], "%Y%m%d")
class(df$added)
```

### 3.3 Data Transformation
#### simplify
Since we will do some prediction on genre it is better to classified the genre into a more simple one
```{r}
length(unique(df$top.genre))
```
as we can see there are hundreds of genre so we will classified it into 17 major genre. Here is our dictionary and implementation
```{r}
genre_dict <- c(
  "dance pop","pop", 
  "pop soul","soul",
  "atl hip hop","hip hop",
  "pop rap","rap",
  "big room","house",
  "canadian hip hop","hip hop",
  "disco house","house",
  "romanian house","house",
  'lilith',"indie",
  'detroit hip hop',"hip hop", 
  'asian american hip hop',"hip hop", 
  'east coast hip hop', "hip hop",
  'neo mellow',"pop", 
  'canadian pop',"pop", 
  'reggae fusion',"reggae", 
  'idol',"pop", 
  'art pop',"pop",
  "talent show","pop", 
  'modern alternative rock',"rock",
  'indietronica',"electronic", 
  'grime',"hip hop", 
  'barbadian pop',"pop", 
  'acoustic pop',"pop",
  'dutch house',"house", 
  'belgian pop',"pop", 
  'contemporary country',"country", 
  'boy band',"pop",
  'celtic rock',"rock", 
  'edm',"electronic", 
  'indie rock',"indie", 
  'australian dance',"dance",
  'british soul',"soul", 
  'eau claire indie',"indie", 
  'dancefloor dnb',"dance",
  'permanent wave',"rock", 
  'hip pop',"pop", 
  'g funk',"funk", 
  'baroque pop',"pop", 
  'indie pop',"pop",
  'chicago rap',"rap", 
  'indie poptimism',"indie", 
  'french shoegaze',"rock",
  'alternative metal',"metal", 
  'indie folk',"indie", 
  'alternative rock',"rock",
  'uk hip hop',"hip hop", 
  'electro house',"house", 
  'garage rock',"rock", 
  'israeli pop',"pop",
  'alternative r&b',"r&b", 
  'australian pop',"pop", 
  'candy pop',"pop", 
  'modern rock',"rock",
  'conscious hip hop',"hip hop", 
  'folk-pop',"pop", 
  'alternative dance',"dance", 
  'k-pop',"pop",
  'gangster rap',"rap", 
  'brostep',"dance", 
  'downtempo',"pop", 
  'la indie',"indie", 
  'bass trap',"dance",
  'metropopolis',"pop", 
  'electropop',"pop", 
  'electro',"electronica", 
  'destroy techno',"dance", 
  'emo',"rock",
  'austrian pop',"pop", 
  'irish pop',"pop", 
  'adult standards',"pop", 
  'modern folk rock',"rock",
  'tropical house',"house", 
  'contemporary r&b',"r&b", 
  'deep disco house',"house",
  'bubblegum dance',"dance", 
  'chill pop',"pop", 
  'comic',"pop", 
  'complextro',"electronica", 
  'nyc rap',"rap",
  'deep groove house',"house", 
  'australian hip hop',"hip hop", 
  'neo soul',"soul",
  'deep house',"house", 
  'french indie pop',"pop", 
  'german pop',"pop", 
  'dutch hip hop',"hip hop",
  'aussietronica',"electronica", 
  'australian indie',"indie", 
  'canadian contemporary r&b',"r&b",
  'kentucky hip hop',"hip hop", 
  'new jersey rap',"rap", 
  'irish singer-songwriter',"pop",
  'ghanaian hip hop',"hip hop", 
  'icelandic indie',"indie", 
  'indie pop rap',"pop",
  'new french touch',"pop", 
  'san diego rap',"rap", 
  'australian psych',"rock",
  'canadian indie',"indie", 
  'alt z',"pop", 
  'danish pop',"pop", 
  'melodic rap',"rap",
  'social media pop',"pop", 
  'london rap',"rap", 
  'florida rap',"rap", 
  'emo rap',"rap",
  'latin',"dance", 
  'ohio hip hop',"hip hop", 
  'dfw rap',"rap", 
  'hawaiian hip hop',"hio hop",
  'dirty south rap',"rap", 
  'afroswing',"swing", 
  'basshall',"dance", 
  'memphis hip hop',"hip hop",
  'bedroom pop',"pop", 
  'hollywood',"pop", 
  'afrofuturism',"pop", 
  'comedy rap',"rap",
  'colombian pop',"pop", 
  'cali rap',"rap", 
  'black americana',"pop",
  'north carolina hip hop',"hip hop", 
  'alternative pop rock',"pop", 
  'dark clubbing',"dance",
  'lgbtq+ hip hop',"hip hop", 
  'afro dancehall',"dance", 
  'argentine hip hop',"hip hop",
  'classic rock',"rock", 
  'uk drill',"hip hop")
val = 0
while (val <= 258)
{
  tempval <- val
  df["top.genre"][df["top.genre"] == genre_dict[tempval+1]] <-  as.character(genre_dict[tempval+2])
  val = val + 2
}

length(unique(df$top.genre))
```

#### Ordinal Encoder
Now, we will do an ordinal encoder to the variable that will be required to do calculation. This transformation will change the character data type that act as a category to number data type. Here is the function to do the encoding.
```{r}
encode_ordinal <- function(x, order = unique(x)) {
  x <- as.numeric(factor(x, levels = order, exclude = NULL))
  x
}
```
Now we can choose the data that will be encoded. In this case we will encode artist type, 
```{r}
new.col.artist.type<-encode_ordinal(df[["artist.type"]])
df$artist.type.enc<-new.col.artist.type
head(df)
```
We will also do the encoder on genre
```{r}
new.col.top.genre<-encode_ordinal(df[["top.genre"]])
df$top.genre.enc<-new.col.top.genre
head(df)
```


#### prediction data
#### normalization
we will need to normalize every learning feature. In this case we will use all of the class that have a number attribute we are going to make the normalize function. The logic of normalize is to make all of the outliers data not too far off the middle value. In other words, this is an action to eliminate the outlier data. The formula to do normalize is:

\begin{equation}
Normalization = \frac {x - min(x)} {max(x) - min(x)}
\end{equation}

```{r}
normalize <- function(x) {
  return ((x - min(x)) / (max(x) - min(x))) }
```

Now, lets assign the data to a new subset. We dont need to assign the genre to the new subset yet. since we do not want to normalize the target of our prediction.
```{r}
df.subset <- df[,6:15]
df.subset$artist.type.enc <- new.col.artist.type
```
After that we can apply the normalization, and add genre to the normalized subset
```{r}
df.subset <- as.data.frame(lapply(df.subset, normalize))
df.subset$top.genre.enc <- new.col.top.genre
head(df.subset)
```
We can see that now everything has been normalized except the genre.
#### Remove duplicate data
@e can now removing the duplicate data since duplicate data can effect the result into an over-fitting model.
```{r}
df.subset <- unique(df.subset)
```
### 3.4 Dataset for analysis
Dataset we use will be all of the dataset given by the kaggle that has been cleaned. We will copy the data into new dataframe variable to keep the original dataframe. We will also show the preview with each of the class attribute

```{r}
df.song<-df
head(df.song)
sapply(df.song, class)
```

Data for prediction
```{r}
df.subset.song<-df.subset
head(df.song)
sapply(df.song, class)
```
## 4. DATA Analysis
### 4.1 Data Model
#### 4.1.1 Exploratory data
We will need 3 types of model data. Which is the original data, first five year data and last five year data. This model will be use for exploratory data analysis.
```{r}
df.song.first <- df.song[ which( df$top.year >= 2010 & df.song$top.year <= 2014),]
df.song.second <- df.song[ which( df$top.year >= 2015 & df.song$top.year <= 2019),]

unique(df.song.first$top.year)
unique(df.song.second$top.year)
```

#### 4.1.2 Prediction data
for the prediction data, we need to splice the data into two. Data splicing basically involves splitting the data set into training and testing data set. We can do this by using a seeder so that the result can be the same even after run in a multiple time. Code below will show how it works

```{r}
set.seed(23231)
dat.d <- sample(1:nrow(df.subset.song),size=nrow(df.subset.song)*0.7,replace = FALSE) #random selection of 70% data.

train <- df.subset.song[dat.d,] # 70% training data
test <- df.subset.song[-dat.d,] # remaining 30% test data

#Creating seperate dataframe for 'Creditability' feature which is our target.
train_labels <- df.subset.song[dat.d,12]
test_labels <-df.subset.song[-dat.d,12]
```

### 4.2 Data Analysis Method
#### 4.2.1 Get top popular song genre for every 5 year
#### 4.2.2 Get top popular artist for every 5 year
#### 4.2.3 Get average duration each 
#### 4.2.4 Get artist which appeared on the charts maximum number of times
#### 4.2.5 Create top genre model and get the best K for the prediction (predict using KNN)
Since we’re using the KNN algorithm to build the model, we must first install the ‘class’ package provided by R. This package has the KNN function in it:
```{r}
#Install class package
#install.packages('class')
# Load class package
library(class)
```
Now we can get the number of training to roughly determine what is the best K value to be use as our model. One of the ways to find the optimal K value is to calculate the square root of the total number of training data in the data set.
```{r}
NROW(train_labels) 
```
The square root of 700 is around 26.04, therefore we’ll create three models. One with ‘K’ value as 26 and the other model with a ‘K’ value as 27 also 25.
```{r}
knn.25 <- knn(train=train, test=test, cl=train_labels, k=25)
knn.26 <- knn(train=train, test=test, cl=train_labels, k=26)
knn.27 <- knn(train=train, test=test, cl=train_labels, k=27)
```
### 4.3 Data Analysis Result
#### 4.3.1 Get top popular song genre for every 5 year
#### 4.3.2 Get top popular artist for every 5 year
#### 4.3.3 Get average duration each 
#### 4.3.4 Get artist which appeared on the charts maximum number of times
#### 4.3.5 Create top genre model and get the best K for the prediction (predict using KNN)
Now we can calculate the proportion of correct classification for k = 26, 27 after building the model according those K value.
```{r}
ACC.25 <- 100 * sum(test_labels == knn.25)/NROW(test_labels)
ACC.26 <- 100 * sum(test_labels == knn.26)/NROW(test_labels)
ACC.27 <- 100 * sum(test_labels == knn.27)/NROW(test_labels)
sprintf("Accuracy for K-Value 25 : %f",ACC.25)
sprintf("Accuracy for K-Value 26 : %f",ACC.26)
sprintf("Accuracy for K-Value 27 : %f",ACC.27)
```
We can also get the best k-value for this prediction by using a function that check all of the optimal k by looping until the number of k-value that we desire. In this case let us loop it until k-value 30
```{r}
i=1
k.optm=1
for (i in 1:30){
  knn.mod <- knn(train=train, test=test, cl=train_labels, k=i)
  k.optm[i] <- 100 * sum(test_labels == knn.mod)/NROW(test_labels)
  k=i
  cat(k,'=',k.optm[i],'\n')
}
```
## 5. Data Visualization
#### 5.1 Get top popular song genre for every 5 year
#### 5.2 Get top popular artist for every 5 year
#### 5.3 Get average duration each 
#### 5.4 Get artist which appeared on the charts maximum number of times
#### 5.5 Create top genre model and get the best K for the prediction (predict using KNN)
We can plot the best K-value for the genre prediction
```{r}
plot(k.optm, type="b", xlab="K- Value",ylab="Accuracy level")
```


## 6. Conclustion

For data prediction we can see that there is a probability of getting close to 100% ( 99.65636% ) prediction this means that the model will have a better accuracy when we pick 1 as our k-value.
